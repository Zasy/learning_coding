### 剑指Offer题目解答及C++版源码

#### 目录

| 序号 |       题目        |                             代码                             | 解答 |
| :--: | :---------------: | :----------------------------------------------------------: | :--: |
|  1   |  赋值运算符函数   | [※](https://github.com/Zasy/learning_coding/剑指Offer/src/1.数组中重复的数字.cpp) |  ※   |
|  2   | 实现Singleton模式 | [※](https://github.com/Zasy/learning_coding/剑指Offer/src/实现Singleton模式.cpp) |      |
|      |                   |                                                              |      |



1. 赋值运算符函数

   - 解答：赋值运算符函数的重载，主要考察的是C++的类的基础设计能力，C++的类的默认函数包括：

     - 构造函数

     - 析构函数

     - 复制构造函数

     - 赋值运算符

     - 取地址函数

       对于赋值运算符的重载主要注意的有以下几个方面：

       - 将输入的形参设置为引用，避免输入形参形成临时变量，导致不必要的复制构造函数的形成，同时，输入参数是不需要变更的，这样就可以声明为const。
       - 函数的返回变量设置为引用，这样返回参数可以连续的调用`a=b=c`， 连续赋值的调用过程是，`a.operator=(b.operator=(c))`, 同时返回引用还有几个比较好的效果：
         - 返回对象就可以支持连续赋值
         - 返回引用一方面可以减少复制构造函数的调用
         - 可以让原始语义更加情晰 比较`(str1=str2)= str3` 返回引用可以支持str1得到str3的值，如果返回对象的话，则临时变量得到了str3的值
       - 作为赋值运算符，原先指针的空间可以删除了，这样可以避免空间的浪费
       - 防止自己赋值给自己的情况
       - 特殊的一方面：标准的异常返回机制，就是利用构造函数和析构函数去释放空间

2. 实现Singleton模式

   单例模式用于一些只有一个实例可以存在的情况，为了避免一个对象的多个实例存在，有两个模式的存在，懒汉模式和饿汉模式的存在：

   - 懒汉模式：懒汉模式在类声明时没有声明实例，在需要对象的时候才生成实例，这里节省了空间，但是需要解决多线程时生成多实例的问题
   - 饿汉模式：饿汉模式在类声明时就给类对象形成了唯一实例，这样可以直接解决多线程的问题，但是浪费了空间